Text Pseudocode:

Summary
One way to state the problem of the Traveling Saleperson Problem (TSP) is this: find the shortest loop that connects n points on a plane assuming each point may appear only once. This formulation is known to be NP-complete. An easier statement (from J.L. Bentley) is this: starting from the left-most point, pass (strictly, meaning only once) some of the points from left to right finally reaching the right-most point, then come back and pass (strictly) the rest of the points. This is the bitonic TSP. It's proven to be solvable in polynomial time for any set of x,y points. [1]

One proposed solution is below. It's inspired by the "classical" bottom-up approach. It goes like this: start from the left-most point and proceed strictly from left to right. This is achieved by sorting on the x-component of the x,y points. Then come back from the right to the left. The process above equals a situation where two robots A and B start from the left-most point and (strictly, meaning only once) pass through different paths to the right-most point. We let DP[i, j] indicate the length of the shortest bitonic path where robot A walks to point i and robot B walks to point j. Robot B is always behind Robot A, so j <= i. If we assume a distance function to give us the distance between two points then let dist(i,j) be the distance between i and j. Now we have the following:

1. When i=j, then:  DP[i,j] = DP[i, i−1] + dist[i,j]
2. When i>j+1 then: DP[i,j] = DP[i−1,j] + dist[i,i−1]
3. When i=j+1 then: DP[i,j] = minimum(DP[j,k] + dist[i,k]), where 1<=k<=j>

Preconditions: 
1. A function to sort x,y points on the x axis
2. A dist(p_1, p_2) function, that returns the euclidean distance between two x,y points: √((x2 – x1)² + (y2 – y1)²). 
3. A 2D array $DP$ initialized to an impossibly large number (for comparing to the current minimum distance).

Steps: (assume that we are indexing from 1)

1. Get the length of the input set of points, $n$.
2. Initialize the $DP[n-1][n]$ cell to the distance between p_n and p_n-1.
3. The three cases as described above will applied in a loop nested in another loop. We'll use these to populate values into the matrix $DP$[][]. The 2D array will be used to store results and a dual loop will substitute for an otherwise recursive process.

Both the time complexity and the space complecity of this algorithm are O(n_2).


References
Li, Jian. “An Improved Dynamic Programming Algorithm for Bitonic TSP.” Applied Mechanics and Materials 347–350 (2013): 3094–98. https://doi.org/10.4028/www.scientific.net/AMM.347-350.3094.
